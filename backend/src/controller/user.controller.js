// backend/src/controllers/user.controller.js
import mongoose from "mongoose";
import { io } from "../lib/socket.js"; // WebSocket ƒë·ªÉ g·ª≠i th√¥ng b√°o realtime
import { Message } from "../models/message.model.js";
import { Payment } from "../models/payment.model.js";
import { User } from "../models/user.model.js";
import { Song } from "../models/song.model.js";

// helper function for cloudinary uploads
// const uploadToCloudinary = async (file) => {
// 	try {
// 		const result = await cloudinary.uploader.upload(file.tempFilePath, {
// 			resource_type: "auto",`
// 		});
// 		return result.secure_url;
// 	} catch (error) {
// 		console.log("Error in uploadToCloudinary", error);
// 		throw new Error("Error uploading to cloudinary");
// 	}
// };

/**
 * Get user profile by ID
 */
export const getUserProfile = async (req, res, next) => {
  try {
    const { userId } = req.params;

    let user;

    // Ki·ªÉm tra n·∫øu userId l√† ObjectId h·ª£p l·ªá
    if (mongoose.Types.ObjectId.isValid(userId)) {
      user = await User.findById(userId);
    } else {
      user = await User.findOne({ clerkId: userId });
    }

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    if (user.isBlocked) {
      return res.status(403).json({ message: "This user is blocked" });
    }

    // Populate d·ªØ li·ªáu
    await user.populate(
      "subscriptionPlan likedSongs followers following playlists"
    );
    if (user.role === "artist") {
      await user.populate("albums");
    }

    res.status(200).json(user);
  } catch (error) {
    console.error("üî• Error in getUserProfile:", error);
    next(error);
  }
};

/**
 * Get multiple user profiles by IDs
 */
export const getUsersByIds = async (req, res, next) => {
  try {
    const { ids } = req.body;
    const artists = await User.find({ _id: { $in: ids } }).select(
      "_id fullName"
    );
    res.status(200).json(artists);
  } catch (error) {
    console.error("Error in getUsersByIds:", error);
    next(error);
  }
};

export const likeSong = async (req, res, next) => {
  try {
    const { songId } = req.params; // L·∫•y songId t·ª´ params
    const userId = req.auth.userId;

    // T√¨m user v√† song
    const user = await User.findOne({ clerkId: userId });
    const song = await Song.findById(songId);

    if (!user || !song) {
      return res.status(404).json({ message: "User or song not found" });
    }

    // Ki·ªÉm tra xem b√†i h√°t ƒë√£ ƒë∆∞·ª£c th√≠ch ch∆∞a
    const isLiked = user.likedSongs.includes(songId);

    if (isLiked) {
      // N·∫øu ƒë√£ th√≠ch, b·ªè th√≠ch
      user.likedSongs = user.likedSongs.filter(
        (id) => id.toString() !== songId
      );
      song.likes = song.likes.filter(
        (id) => id.toString() !== user._id.toString()
      );
    } else {
      // N·∫øu ch∆∞a th√≠ch, th√™m v√†o danh s√°ch th√≠ch
      user.likedSongs.push(songId);
      song.likes.push(user._id);
    }

    await user.save();
    await song.save();

    res.status(200).json({
      message: isLiked
        ? "Song unliked successfully"
        : "Song liked successfully",
      isLiked: !isLiked, // Tr·∫£ v·ªÅ tr·∫°ng th√°i m·ªõi c·ªßa b√†i h√°t (ƒë√£ th√≠ch hay ch∆∞a)
    });
  } catch (error) {
    console.error("Error toggling like:", error);
    next(error);
  }
};

/**
 * Get current authenticated user profile
 */
export const getMe = async (req, res, next) => {
  try {
    // Ensure user is authenticated
    if (!req.auth || !req.auth.userId) {
      return res.status(401).json({ message: "Unauthorized - Please log in" });
    }

    const myId = req.auth.userId;

    // Find user by clerkId
    const user = await User.findOne({ clerkId: myId })
      .populate("subscriptionPlan")
      .populate("likedSongs")
      .populate("followers")
      .populate("following")
      .populate("playlists");

    if (!user) {
      return res
        .status(404)
        .json({ message: "User not found. Please register first." });
    }

    // If user is an artist, populate their albums
    if (user.role === "artist") {
      await user.populate("albums");
    }

    res.status(200).json(user);
  } catch (error) {
    console.error("Error in getMe:", error);
    next(error);
  }
};

/**
 * Update user profile
 */
export const updateUserProfile = async (req, res, next) => {
  try {
    const myId = req.auth.userId;
    const { fullName, imageUrl } = req.body;

    if (imageUrl && !imageUrl.startsWith("http")) {
      return res.status(400).json({ message: "Invalid image URL" });
    }

    const updatedUser = await User.findOneAndUpdate(
      { clerkId: myId },
      { fullName, imageUrl },
      { new: true }
    );

    if (!updatedUser) {
      return res.status(404).json({ message: "User not found" });
    }

    res.status(200).json(updatedUser);
  } catch (error) {
    next(error);
  }
};

/**
 * Follow a user
 */

export const followUser = async (req, res, next) => {
  try {
    const myId = req.auth.userId;
    const { userId } = req.params;

    if (myId === userId) {
      return res.status(400).json({ message: "You cannot follow yourself" });
    }

    const user = await User.findById(userId);
    const me = await User.findOne({ clerkId: myId });

    if (!user || !me) {
      return res.status(404).json({ message: "User not found" });
    }

    if (user.isBlocked || me.isBlocked) {
      return res.status(403).json({ message: "Cannot follow a blocked user" });
    }

    if (me.following.includes(userId)) {
      return res
        .status(400)
        .json({ message: "You are already following this user" });
    }

    me.following.push(userId);
    user.followers.push(me._id);

    await me.save();
    await user.save();

    io.emit("new_follower", { userId: user._id, followerId: me._id });

    res.status(200).json({ message: "Followed successfully" });
  } catch (error) {
    next(error);
  }
};

/**
 * Unfollow a user
 */
export const unfollowUser = async (req, res, next) => {
  try {
    const myId = req.auth.userId;
    const { userId } = req.params;

    const user = await User.findById(userId);
    const me = await User.findOne({ clerkId: myId });

    if (!user || !me) {
      return res.status(404).json({ message: "User not found" });
    }

    me.following = me.following.filter((id) => id.toString() !== userId);
    user.followers = user.followers.filter(
      (id) => id.toString() !== me._id.toString()
    );

    await me.save();
    await user.save();

    res.status(200).json({ message: "Unfollowed successfully" });
  } catch (error) {
    next(error);
  }
};

/**
 * Get user's payment history
 */
export const getPaymentHistory = async (req, res, next) => {
  try {
    const myId = req.auth.userId;
    const user = await User.findOne({ clerkId: myId });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const payments = await Payment.find({ userId: user._id }).populate(
      "planId"
    );

    if (payments.length === 0) {
      return res.status(404).json({ message: "No payment history found" });
    }

    res.status(200).json(payments);
  } catch (error) {
    next(error);
  }
};

/**
 * Get paginated messages between two users (optimized for chat apps)
 */

export const getMessages = async (req, res, next) => {
  try {
    const myClerkId = req.auth.userId; // L·∫•y ID c·ªßa ng∆∞·ªùi g·ª≠i request t·ª´ Clerk
    const { userId } = req.params; // L·∫•y ID c·ªßa ng∆∞·ªùi nh·∫≠n t·ª´ request params

    let { limit = 20, lastMessageId } = req.query;
    limit = parseInt(limit);

    // üîπ Truy v·∫•n theo `clerkId` (KH√îNG d√πng ObjectId n·ªØa)
    let query = {
      $or: [
        { senderId: myClerkId, receiverId: userId },
        { senderId: userId, receiverId: myClerkId },
      ],
    };

    // N·∫øu c√≥ lastMessageId, l·ªçc tin nh·∫Øn c≈© h∆°n
    if (lastMessageId) {
      const lastMessage = await Message.findById(lastMessageId);
      if (lastMessage) {
        query.createdAt = { $lt: lastMessage.createdAt };
      }
    }

    // üîπ L·∫•y tin nh·∫Øn m·ªõi nh·∫•t tr∆∞·ªõc
    const messages = await Message.find(query)
      .sort({ createdAt: -1 })
      .limit(limit);

    res.status(200).json({
      hasMore: messages.length === limit,
      messages: messages.reverse(), // Hi·ªÉn th·ªã tin nh·∫Øn theo th·ª© t·ª± t·ª´ c≈© ƒë·∫øn m·ªõi
    });
  } catch (error) {
    console.error("‚ùå L·ªói khi l·∫•y tin nh·∫Øn:", error);
    next(error);
  }
};

export const sendMessage = async (req, res, next) => {
  try {
    const { senderId, receiverId, content } = req.body;

    // ‚úÖ T√¨m user b·∫±ng `clerkId` v√† l·∫•y `_id` MongoDB
    const sender = await User.findOne({ clerkId: senderId });
    const receiver = await User.findOne({ clerkId: receiverId });

    if (!sender || !receiver) {
      return res.status(404).json({ error: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
    }

    const message = await Message.create({
      senderId: sender._id, // S·ª≠ d·ª•ng `_id` t·ª´ MongoDB thay v√¨ `clerkId`
      receiverId: receiver._id,
      content,
    });

    res.status(201).json({ message });
  } catch (error) {
    console.error("‚ùå L·ªói khi l∆∞u tin nh·∫Øn v√†o database:", error);
    res.status(500).json({ error: "L·ªói server khi l∆∞u tin nh·∫Øn" });
  }
};

/**
 * Update user's subscription plan
 */
export const updateSubscriptionPlan = async (req, res, next) => {
  try {
    const myId = req.auth.userId;
    const { planId } = req.body;

    const plan = await SubscriptionPlan.findById(planId);
    if (!plan) {
      return res.status(404).json({ message: "Subscription plan not found" });
    }

    // T√≠nh to√°n th·ªùi gian h·∫øt h·∫°n g√≥i Premium
    const newExpiration = new Date(
      Date.now() + plan.durationInDays * 24 * 60 * 60 * 1000
    );

    const user = await User.findOneAndUpdate(
      { clerkId: myId },
      {
        subscriptionPlan: plan._id,
        premiumExpiration: newExpiration,
        role: "premium", // **C·∫≠p nh·∫≠t role th√†nh "premium" khi user mua g√≥i**
      },
      { new: true }
    ).populate("subscriptionPlan");

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    res
      .status(200)
      .json({ message: "Subscription updated successfully", user });
  } catch (error) {
    next(error);
  }
};

export const checkArtist = async (req, res, next) => {
  try {
    const currentUser = await clerkClient.users.getUser(req.auth.userId);
    const user = await User.findOne({ clerkId: currentUser.id });

    if (!user || user.role !== "artist") {
      return res.status(403).json({
        artist: false,
        message: "Unauthorized - you must be an artist",
      });
    }

    res.status(200).json({ artist: true });
  } catch (error) {
    next(error);
  }
};

export const checkPremium = async (req, res, next) => {
  try {
    const currentUser = await clerkClient.users.getUser(req.auth.userId);
    const user = await User.findOne({ clerkId: currentUser.id });

    if (!user || user.role !== "premium") {
      return res.status(403).json({
        premium: false,
        message: "Unauthorized - you must be a premium user",
      });
    }

    res.status(200).json({ premium: true });
  } catch (error) {
    next(error);
  }
};

/**
 * createSong
 */
